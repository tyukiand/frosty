# frosty

**F**unctional / p**ro**cess-calculus based, 
**s**tatically **ty**ped experimental programming language.

## Build Status

Compiler:

<SCALA-BADGES>

Virtual Machine:

<RUST-BADGES>

<ENVIRONMENT-INFO>

## What's in this Repository?

Proof-of-concept compiler and virtual machine for an experimental
programming language based on process calculus.

  * The compiler is in the `frostyc` subdirectory (Scala code)
  * The VM is in the `frostyvm` subdirectory (Rust code)
  * Validation suite is in the `validation` subdirectory (Frosty code)
  * This `README.md` is also generated by SBT from the sources in `readmesrc`.

## What is `frostyc`/`frostyvm`?

"Frosty" is an experimental programming language based on a variant of
[Milner's π-calculus](https://en.wikipedia.org/wiki/%CE%A0-calculus), 
with some support for statically typed functional programming built on top
of it. The implementation currently consists of a compiler `frostyc` implemented
in Scala and a very simple virtual machine `frostyvm` written in Rust.
The main goal of the project is to gain a better understanding of
programming languages based on process calculi, such as
[Rholang](https://github.com/rchain/rchain/tree/master/rholang) and
[Pict](https://en.wikipedia.org/wiki/Pict_(programming_language)). Some
terminology is obviously borrowed from Rholang.

Main goals of this experiment are:
  
  1. Confirm that the core calculus is powerful enough to support
     arbitrary computation (guarded replication of processes, "contracts").
  2. Understand how functional programming primitives can be embedded into 
     this process calculus.
  3. Build the compiler itself from a minimum number of simple data structures,
     which could be easily defined in the language itself.
  4. More generally: gain a deeper understanding of programming languages
    based on process-calculi instead of the more common λ-calculus.

Below, we briefly describe some things that already work, but before we do
that, here is a list of things that *don't work* (at least not yet):

  1. There is currently no way to introduce user-defined data structures.
    (`data` / `trait` systems are work in progress, and all the other
    features crucially depend on them).
  2. No support for random access memory (no built-in arrays)
  3. No IO (almost; it can print to stdout)
  4. No standard library.
  5. Current VM implementation useful only for tiny tests on
     a single physical machine.

In its current state, the language is really just a proof of concept, it
cannot be used for anything practical, because several crucial components
are missing.

In the following subsections, we briefly describe the things that work
without user-defined datatypes and without any libraries.

### The Core Process Calculus

Basically, Frosty programs describe a bag of *processes* that are
running in parallel.
Processes can communicate over *channels* by 
  *sending* and *receiving* messages.
New unique channel names can be generated whenever the need arises.
Processes can be *frozen* and sent as messages.
On the receiving side, processes can be *unfrozen* again, and
 start their execution.


The syntax for the various core constructs is as follows:

  * **Channels**: Names of built-in channels and user-defined constant channels
    look somewhat like paths in a Unix file system, enclosed in backticks,
    for example

        `/sys/out`
        `/lang/int_to_string`
        `/my/own/channel`

    are valid channel names. The only other kind of channel names are
    *unforgeable* names (essentially randomly generated UUIDs), which are
    generated by the `new`-operator (see below).

  * **Local variables**: Some operators are binders of local variables.
    Local variables are denoted by ordinary identifiers, e.g. 
    `x`, `myVar`, `MY_CONST`. It's pretty much the same as in C or Java.

  * **Parallel** processes: If `P1`, `P2`, ..., `PN` are some processes,
    then `P1 | P2 | ... | PN` are the `N` processes running in parallel.
    For example, the following program will send 
    two strings (`"a"` and `"b"`) to the built-in channel `/sys/out`.
    The order in which the two messages will be printed is not deterministic.

        `/sys/out` ! ("a") | `/sys/out` ! ("b")

    The `|`'s can be omitted in the top-level definitions.

  * **Send**: If `c` is a channel, `x1, ... , xN` some messages,
    then `c ! (x1, ... , xN)` sends the tuple with the messages to the 
    channel `c`. 
    For example, this is a process that sends a string to the special 
    built-in channel `/sys/out`:

        <FILE:validation/test101_hello_world.frosty>

  * **Receive**: Given a channel `c`, 
    local variable names `n1, ..., nK`,
    and the body process `B` 
    (which can contain `n1, ..., nK` as free variables),
    the process `c ? (n1, ..., nk) { B }` will receive 
    values on channel `c`, 
    bind them to the local variables
    `n1, ..., nK`, substitute them in the body `B`,
    and then continue with the modified body. For example,
  
        <FILE:validation/test102_send_receive.frosty>

    will communicate on the channel `c`, 
    substitute `"Hello"` for `how` and `"World"` for `whom`,
    and then continue by sending the combined message to standard output.

  * **New** channels can be generated anywhere using the `new` keyword, which
    binds a new channels to the given variables. The previous example could be
    rewritten as follows:

        <FILE:validation/test103_new.frosty>

    The difference would be that the temporary channel `temp` gets instantiated
    as an unforgeable name, which cannot be created anywhere outside of the 
    `new` block.
    The type of the values that can be sent on the channel has to be specified
    in advance (in this case, `temp` can be used to send two strings at once).

  * **Freeze** and **Unfreeze**: A process can be *frozen* with `#p`.
    Frozen processes are susceptible to substitution.
    Frozen processes are values, and can thus be sent as messages, or used 
    as arguments to function calls (more about this later).
    Unfreezing simply starts the frozen process.
    For example, the following piece of code results in `"Yes!"` being printed
    three times:

        <FILE:validation/test104_freeze_unfreeze_thrice.frosty>

    Freezing and unfreezing is also crucial for replication (which is currently
    not part of the core calculus).

The state of the Frosty virtual machine is
 just one big term consisting of parallel processes communicating on
 channels. There are no explicit threads, no stacks, and no heap -  only
 bunch of queues with sending / receiving processes.

### Contracts

Guarded replication of receiving processes is implemented by *contracts*
(similar to Rholang's "smart contracts"). Unlike a receiving
process, a contract can be called multiple times, it does not disappear after
processing the first message:

    <FILE:validation/test105_print_twice_contract.frosty>

Contracts are fire-and-forget - 
unlike functions, contracts aren't obliged to respond with a returned result.
Invocation of a contract is a process, not an expression.

### Functions and Expressions

By *functions*, we mean special contract-like entities that take some 
parameters, and then respond with exactly one value.
They are not functions in the
mathematical sense or in the sense of pure FP (*we do not necessarily endorse
the usage of such "functions", we merely observe that these were the most
obvious structures that had relatively nice compositional properties, and were
the easiest to implement in the given process calculus*).
Since purity is not enforced, the resulting flavor of functional programming
seems to be closer to ML or Scala rather than e.g. Haskell.

Current implementation provides the most rudimentary support for basic
functional programming, in particular:

  * nested expressions (function invocations are expressions, not processes),
  * user-defined functions,
  * (mutual) recursion,
  * first-class functions (functions as values, higher-order functions)

are supported.

Evaluation is eager (all arguments are evaluated before
being passed to a function), the order in which the arguments are evaluated is
undefined (they can be evaluated in any order, also in parallel).

All functions are always called in non-blocking fashion (as if the
entire computation were inside some kind of a `Future`-monad).

  * **Invocation**: Functions are called using the `f(x1, ..., xN)` syntax.
    For example, here is how the built-in `int_to_string` function is called:

        <FILE:validation/test108_int_to_string.frosty>

    In this particular context, the `+` stands for string concatenation, and is
    merely syntactic sugar for the invocation of yet another built-in function 
    `/lang/concat_string`.

  * **Definition**: Here is how the recursive factorial function might be 
    defined and called:

        <FILE:validation/test107_factorial_function_def.frosty>

  * **Higher-order functions**: There is currently no syntactic sugar for
    anonymous lambdas, but we can use `new` to generate a new name for the
    function that we want to return, then define the function, then return the
    new name:

        <FILE:validation/test109_compose_int_int.frosty>

    In this case, the `new`-block is an expression, not a process 
    (see second part of the next section for more information about
    block-expressions).

### Block-Expressions and `await`

The `await` keyword can be used to transform an expression of type 
`Chan[X]` into an expression of type `X` by awaiting a single value on the
channel. For example, in

    <FILE:validation/test110_await.frosty>

the expression `await c` will wait for the value `"Hi"` on the channel `c`,
then concatenate it with a line break, and send it to stdout. Note that
no threads are blocked at any point.

The `await` keyword seems particularly useful in combination with another
feature: block-expressions. The idea is that one can create some temporary
"promise"-like channel, start a bunch of processes that should eventually
write a single value to this channel, and then `await` on the channel, and
use the result in some larger expression.

The block-expressions are derived from syntactically similar process
constructors.
For every process that has the general shape

    <waitForSomething> { <andThenRunThisProcess> }

has a corresponding expression of similar shape. In particular:

  * *Receive-expressions*: `channel ? (a1, ..., aN) { P1 | ... | Pk | expr }`
  * *New-expressions*: `new v1: T1, ... vN: TN { P1 | ... | Pk | expr }`
  * *Par-expressions*: `{ Proc | expr }`

can all be used in a position where an expression (not a process) is
expected.

For example, here is how we can use `new` in a position where a value-like 
expression is expected:

    <FILE:validation/test111_new_await.frosty>

**Anonymous functions**: 
One interesting property of `new`-expressions is that they can be used to
write down expressions that behave like anonymous functions:

    <FILE:validation/test115_anonymous_function.frosty>

There is currently no syntactic sugar for anonymous functions.

### Type System

All expressions in Frosty are statically typed.
Currently, no user defined types can
be introduced, and the typesystem itself is very similar to 
[STLC](https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus).
The only way to form types are the following:

  * **Unit type**: `Unit` is a type.
  * **Primitive types**: `String`, `Boolean`, `Int` are types.
  * **Process types**: `Proc` is the type of frozen processes (special values
    that can be sent like any other message).
  * **Channel types**: If `T1, ..., TK` are some types, then `Chan[T1, ..., Tk]`
    is the type of channel that can transmit only packages of `k` values of
    types `T1, ..., Tk`. Here is a channel that always transmits a string, an
    integer, and a binary operator:

        <FILE:validation/test112_channel_typedecl.frosty>

  * **Contract types**: If `X1, ..., Xk` are some types, then `Run[X1, ..., Xk]`
    is the type of a contract that can be repeatedly invoked with 
    arguments of types `X1, ..., Xk`. 
    For example, here is a contract that must be invoked with an `Int` and
    another contract as arguments:

        <FILE:validation/test113_contract_typedecl.frosty>

  * **Function types**: If `X1, ..., Xk` and `Y` are some types, then
    `Fun[X1, ..., Xk, Y]` is the type of functions that take arguments of types
    `X1, ..., Xk`, and eventually return an `Y`.

One important thing to understand is that only *expressions* have types.
Processes do not have types - they just run, without ever "returning" any
values. This is completely analogous to expressions vs. statements in
imperative programming languages - there, statements also don't have any types
assigned to them.

### Primitive Types and Built-in Channels

Following primitive datatypes are currently supported:

  * `String`:
    Literals are enclosed in double quotes. 
    Most rudimentary escaping (`\n`, `\t` etc.) also works.
  * `Boolean`: `true`, `false` are the only two values.
  * `Int`: 32-bit integers. Only decimal syntax is supported.

Basic logical operations are written using Python-style syntax:

    <FILE:validation/test114_comparison_and_logic.frosty>

Basic arithmetic operations can be written in the usual infix syntax:

    <FILE:validation/test116_operator_precedence.frosty>

The operator precedence *should* be "as usual" (C/Java/Scala style). 
Use parentheses if in doubt.

Here is a selection of built in functions that operate on the built-in types:

    `/lang/eq_unit`               Fun[Unit, Unit, Boolean]
    `/lang/unit_to_string`        Fun[Unit, String]
    `/lang/eq_boolean`            Fun[Boolean, Boolean, Boolean]
    `/lang/and_boolean`           Fun[Boolean, Boolean, Boolean]
    `/lang/or_boolean`            Fun[Boolean, Boolean, Boolean]
    `/lang/not_boolean`           Fun[Boolean, Boolean, Boolean]
    `/lang/xor_boolean`           Fun[Boolean, Boolean, Boolean]
    `/lang/boolean_to_string`     Fun[Boolean, String]
    `/lang/eq_int`                Fun[Int, Int, Boolean]
    `/lang/le_int`                Fun[Int, Int, Boolean]
    `/lang/leq_int`               Fun[Int, Int, Boolean]
    `/lang/gr_int`                Fun[Int, Int, Boolean]
    `/lang/geq_int`               Fun[Int, Int, Boolean]
    `/lang/int_to_string`         Fun[Int, String]
    `/lang/add_int`               Fun[Int, Int, Int]
    `/lang/neg_int`               Fun[Int, Int, Int]
    `/lang/sub_int`               Fun[Int, Int, Int]
    `/lang/mul_int`               Fun[Int, Int, Int]
    `/lang/div_int`               Fun[Int, Int, Int]
    `/lang/rem_int`               Fun[Int, Int, Int]
    `/lang/eq_string`             Fun[String, String, Boolean]
    `/lang/concat_string`         Fun[String, String, String]

### Packages and Imports

A basic namespace system is in place. Every symbol is uniquely identified by
a path of shape:

    `/pkg1/pkg2/pkg3/.../pkgN/name`

Relative paths are allowed:

    `relativePackage/.../name`

Symbols can be grouped into packages, which are created using `package`
keyword. There can be arbitrarily many nested packages in a single file.

Imports are similar in spirit to Scala's import clauses:

  * Absolute and relative imports are allowed:

        import `a/b`
        import `/a/b`

  * Wildcards `*` import all symbols:

        import `a/*`

  * Renaming imports are possible:

        import `a/{b => bRenamedToSthElse}`

  * It's possible to shadow selected symbols, and then import the rest:

        import `a/{thisWillBeShadowed => *, *}`

  * It's possible to combine renaming and shadowing:

        import `a/{b => c, d => *, *}

Example demonstrating several import clauses:

    <FILE:validation/test117_imports.frosty>

### Comments

Currently, only non-nesting  "documentation-style" block-comments are provided:

    <FILE:validation/test106_comments.frosty>

Rest-of-the-line comments, or block-comments starting with `/*` are currently
not supported.

## Building the compiler and the virtual machine.

The compiler is written in Scala, and built with SBT.
The virtual machine is written in Rust, and built with Cargo.
The compiler requires the virtual machine during the tests, so that Cargo
is required to make the SBT tests run successfully (otherwise, the 
validation suite is ignored, and no tests are executed).

Requirements for building and running the compiler / vm:

  * Linux (might build on other Unix-like systems,
  but probably not on Windows)
  * Cargo ([rustup download page](https://rustup.rs/))
  * SBT ([SBT download page](https://www.scala-sbt.org/))

**To build the virtual machine separately**, `cd` into `frostyvm` and run

    cargo build

This will produce the executable `frosty_vm` in `frostyvm/target/debug`
(there is currently no reason to build optimized versions of it).

**To build both the compiler and the virtual machine**, `cd` into
`frostyc` and run

    sbt assembly

This will produce the archive `frosty.jar` in `frostyc/target/scala-2.12`,
which then can be invoked as follows to compile Frosty code:

    scala frosty.sbt inputFile.frosty

The compiled binary will be saved in `inputFile.procs`. Run

    scala frosty.sbt --help

to see more options (e.g. specifying output path, listing compiler phases,
inspect output of each compiler phase etc.)

The compiled `.procs` files can be executed with the `frosty_vm` as follows:

    frosty_vm inputFile.procs

Some example programs can be found in `validation` subdirectory.

## Generating this README

All code snippets in this README are
tested by Scalatest and SBT to prevent devastating bit rot due to
an evolving language with highly unstable syntax.

This readme is generated from the sources in `./readmesrc` and Frosty source
code in `./validation`. It should not be modified manually. 

To generate the `README.md`, you can either run
the `generateReadme.sh` script with `bash`, or go to the `frostyc` 
subdirectory with the compiler, start `sbt` and then in the SBT console run:

  1. `clean`
  2. `coverageOn`
  3. `test`
  4. `coverageReport`
  5. `generateReadme`

manually. If you only modified `readmesrc/README.md` and don't want to 
recompile anything, running just the `generateReadme` command inside `sbt`
should be sufficient.

If you want to take a look at the README before pushing it to repository,
you probably also want to run something like

    markdown README.md > readme.hmtl

and then open the resulting `html` with the browser.
