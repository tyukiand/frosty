sbtVersion := "1.2.6"
scalaVersion := "2.12.7"
scalacOptions ++= Seq("-deprecation", "-feature")

organization := "io.github.tyukiand"
name := "frostyc"
version := "0.1.0"
libraryDependencies += "org.typelevel" %% "cats-core" % "1.5.0"
libraryDependencies += "org.typelevel" %% "cats-effect" % "1.1.0"
libraryDependencies += "com.github.scopt" %% "scopt" % "3.7.0"
libraryDependencies += "org.scalactic" %% "scalactic" % "3.0.5"
libraryDependencies += "org.scalatest" %% "scalatest" % "3.0.5" % "test"

antlr4Settings
antlr4Version in Antlr4 := "4.7.1"
antlr4GenListener in Antlr4 := true
antlr4GenVisitor in Antlr4 := true
antlr4Dependency in Antlr4 := "org.antlr" % "antlr4" % "4.7.1"
antlr4PackageName in Antlr4 := Some("frosty.antlr4")

resolvers += Resolver.sonatypeRepo("releases")
addCompilerPlugin("org.spire-math" %% "kind-projector" % "0.9.8")

mainClass in assembly := Some("frosty.Main")
assemblyJarName in assembly := "frostyc.jar"





// Generates bunch of .scala source code files from `../bytecode_format.rs`.
sourceGenerators in Compile += Def.task{
  val OpcodeTableRustPath = "../bytecode_format.rs"
  val tableFile = file(OpcodeTableRustPath)

  def genFiles(inputs: Set[File]): Set[File] = {
    println(s"Translating Opcode constants from Rust macros to Scala.")

    sealed trait OpcodeEntry {
      def constNameInSource: String
      def opcode: Byte
    }

    case class ChannelName(
      constNameInSource: String,
      opcode: Byte,
      path: List[String],
      typeStr: String
    ) extends OpcodeEntry

    case class TermConstructor(
      constNameInSource: String,
      opcode: Byte
    ) extends OpcodeEntry

    def addGeneratedCodeWarning(
      originalSource: String,
      code: String
    ): String = {
      code
        .split("\n")
        .map("/*!!!*/".+)
        .mkString(
          "/* !!! GENERATED CODE, DO NOT EDIT MANUALLY !!!*/\n" +
          "/* original source: " + originalSource + " */\n" +
          "/* generated by:    build.sbt */\n",
          "\n",
          "\n/* !!! /generated code !!! */"
        )
    }


    // load opcodes from the `../bytecode_format.rs` table
    val opcodeEntries: List[OpcodeEntry] = {

      // all lines from the file containing the opcodes
      val opcodeFileLines = IO.read(inputs.head).split("\n")
    
      // ------------ Run some basic sanity checks on the table. ---------------
      // find start of the table
      val tableStartLineIndex = opcodeFileLines
        .zipWithIndex
        .find(_._1.matches("^.*<TABLE-START>.*$"))
        .get
        ._2
    
      // only the lines of the table, without header comment section
      val opcodeTableLines = opcodeFileLines
        .drop(tableStartLineIndex)
        .filterNot(_.isEmpty)
    
      if (opcodeTableLines.size != 256) {
        printf(
          "Warning: %d != 256 lines after table start\n",
          opcodeTableLines.size
        )
      }
    
      // regex for special comments that look like `// <number>`
      val offsetRegex = "^// *([\\d]+)[^\\d]*$".r
    
      // check that all the positions of the explicit `// <number>` comments are
      // in the right places.
      for {
        (line, idx) <- opcodeFileLines.zipWithIndex
        m <- offsetRegex.findAllMatchIn(line) 
      } {
        val expectedOffset = m.group(1).toInt
        val actualOffset = idx - tableStartLineIndex
        if (expectedOffset != actualOffset) {
          println(
            "Warning: bytecode format table entry " + 
            s"${m.group(1)} at bad line offset ${expectedOffset}, " +
            s"actual offset is ${actualOffset}"
          )
        }
      }
    
      // -------------------------- Parse the table ----------------------------
      // regexes of the interesting strings
      val TermConstructorRegex = (
        "^term_constructor!\\(" +
        "([A-Z_]+),\\s*" +
        "(\\d+)\\s*" +
        "\\);.*"
      ).r
    
      val ChannelNameRegex = (
        "^channel_name!\\(" +
        "([A-Z0-9_]+),\\s*" + // name
        "([\\d]+),\\s*" +   // byte
        "(\"[a-z0-9_/]+\"),\\s*" + // path in quotes
        "\\{([A-Za-z0-9_\\[\\](), ]+)\\}" + // type enclosed in curly braces
        "\\);.*$"
      ).r
    
      val EmptyOrCommented = "^(\\s*|//.*)$".r
    
      // helper method for translating SCREAMING_SNAKE to CamelCase
      def toCamelCase(s: String): String = {
        s.split("_").map(_.toLowerCase.capitalize).mkString
      }

      // extract constructors and channels from the file
      val opcodeEntries: List[OpcodeEntry] = opcodeTableLines.collect {
        case TermConstructorRegex(n, b) => 
          TermConstructor(toCamelCase(n), b.toByte)
        case ChannelNameRegex(n, b, p, t) =>
          ChannelName(
            toCamelCase(n), 
            b.toByte,
            p.replaceAll("\"", "").split("/").toList.tail,
            t
          )
      }(collection.breakOut)

      opcodeEntries
    }

    
    // Generate `frosty.bytecode.format`
    val bytecodeFormatSourceFile: File = {
      val constantDefinitions = opcodeEntries
        .map(e => s"  val ${e.constNameInSource}: Byte = ${e.opcode}")
        .mkString("\n")
    
      // Save the table with opcodes
      val bytecodeFormatSourceFile = (sourceManaged in Compile).value /
        "scala" / "frosty" / "bytecode" / "format" / "package.scala"
    
      IO.write(
        bytecodeFormatSourceFile,
        addGeneratedCodeWarning(
          OpcodeTableRustPath,
          "package frosty.bytecode\n\npackage object format {\n" + 
          constantDefinitions +
          "\n}\n"
        )
      )

      bytecodeFormatSourceFile
    }

    // Generate `frosty/bytecode/builtin/BuiltInChannel.scala`
    val bytecodeBuiltInChannelSourceFile: File = {
      val bytecodeBuiltInChannelSourceFile = (sourceManaged in Compile).value /
        "scala" / "frosty" / "bytecode" / "builtin" / "BuiltInChannel.scala"

      val builtInChannelSourceCode = addGeneratedCodeWarning(
        OpcodeTableRustPath,
        """|package frosty.bytecode.builtin
           |import frosty.bytecode.format
           |import frosty.types.Type
           |import frosty.antlr4.Antlr4FrostyParser
           |import frosty.InMemorySnippet
           |
           |sealed trait BuiltInChannel {
           |  def opcode: Byte
           |  def path: List[String]
           |  def typ: Type
           |}
           |
           |""".stripMargin + 
        (
          for (ChannelName(name, byt, path, typ) <- opcodeEntries) yield {
            s"""|case object ${name} extends BuiltInChannel {
                |  val opcode = format.${name}
                |  val path = List(${path.map("\"" + _ + "\"").mkString(",")})
                |  lazy val typ = {
                |    Antlr4FrostyParser.parseType(
                |      InMemorySnippet(s"<none>", "${typ}")
                |    ).right.get
                |  }
                |}
                |""".stripMargin
          }
        ).mkString("\n") +
        """|
           |object BuiltInChannel {
           |
           |  private val pathToBuiltInChannel
           |  : Map[List[String], BuiltInChannel] = Map(
           |""".stripMargin +
        (
          for (ChannelName(name, byt, path, typ) <- opcodeEntries) yield {
            val pathWithQuotes = path.map(x => '"' + x + '"').mkString(",")
            s"      List(${pathWithQuotes}) -> ${name},"
          }
        ).mkString("\n") +
        """|
           |    )
           |
           |  /** Set of all built-in channels */
           |  val all: Set[BuiltInChannel] = pathToBuiltInChannel.values.toSet
           |
           |  def tryFrom(p: List[String]): Option[BuiltInChannel] =
           |    pathToBuiltInChannel.get(p)
           | 
           |  val typeOf: Map[BuiltInChannel, Type] = List(
           |""".stripMargin +
        (
          for (ChannelName(name, _, _, typ) <- opcodeEntries) yield {
            "    %s -> \"%s\"".format(name.toString, typ)
          }
        ).mkString(",\n") +
        """|
           |  ).map{ 
           |    case (k, v) => (
           |      k,
           |      Antlr4FrostyParser.parseType(
           |        InMemorySnippet(s"<snippet:${v}>", v)
           |      ).right.get
           |    )
           |  }.toMap
           |}""".stripMargin
      )
          
    
      IO.write(
        bytecodeBuiltInChannelSourceFile,
        builtInChannelSourceCode
      )

      bytecodeBuiltInChannelSourceFile
    }

    // List all generated files
    Set(
      bytecodeFormatSourceFile,
      bytecodeBuiltInChannelSourceFile
    )
  }

  val cachedFun = FileFunction.cached(
    cacheBaseDirectory = streams.value.cacheDirectory / "opcodes",
    inStyle = FilesInfo.lastModified,
    outStyle = FilesInfo.exists
  )(genFiles)

  cachedFun(Set(tableFile)).toSeq
}.taskValue


// Builds `README.md` in the parent directory, using test coverage data provided
// by Scoverage. 
lazy val generateReadme = taskKey[Unit]("generates readme with coverage badges")
generateReadme := {
  val readmeSrc = IO.read(file("../readmesrc/README.md"))

  /** URL for parameterized Shields.io badge */
  def shieldUrl(label: String, message: String, color: String): String = {
   s"""https://img.shields.io/static/v1.svg?""" +
   s"""label=${label}&message=${message}&color=${color}"""
  }
  
  /** URL embedded in Markdown */
  def shieldMd(label: String, message: String, color: String): String = {
    s""" ![${label}: ${message}](${shieldUrl(label, message, color)})"""
  }

  /** Badge for numeric values with red-yellow-green colors */
  def shieldMdThresh(
    label: String,
    value: Double,
    yellowThresh: Double,
    greenThresh: Double
  ): String = {
    val color = 
      if (value >= greenThresh) "green" else
      if (value >= yellowThresh) "yellow" else
      if (value > 0) "orange" else
      "red"
    shieldMd(label, value.toString, color)
  }

  val buildSuccessful = (compile in Compile).result.value match {
    case Value(_) => true
    case _ => false
  }

  val buildBadge = if (buildSuccessful) {
    shieldMd("local-scala-build", "passing", "green")
  } else {
    shieldMd("local-scala-build", "failing", "red")
  }

  val testsSuccessful = (test in Test).result.value match {
    case Value(_) => true
    case _ => false
  }

  val testBadge = if (testsSuccessful) {
    shieldMd("local-scala-tests", "passing", "green")
  } else {
    shieldMd("local-scala-tests", "failing", "red")
  }

  val sbtVers = sbtVersion.value
  val scalVers = scalaVersion.value
  val cargoVers = "cargo --version".!!
  val rustcVers = "rustc --version".!!

  import scala.sys.process._
  val rustBase = file("../frostyvm")
  val cargoBuildSuccessful = Process(Seq("cargo", "build"), rustBase).! == 0
  val cargoTestSuccessful = Process(Seq("cargo", "test"), rustBase).! == 0

  val cargoBuildBadge = if (cargoBuildSuccessful) {
    shieldMd("local-rust-build", "passing", "green")
  } else {
    shieldMd("local-rust-build", "failing", "red")
  }

  val cargoTestBadge = if (cargoTestSuccessful) {
    shieldMd("local-rust-test", "passing", "green")
  } else {
    shieldMd("local-rust-test", "failing", "red")
  }

  import java.time.ZonedDateTime
  import java.time.format.DateTimeFormatter._

  val now = java.time.ZonedDateTime.now.format(ISO_LOCAL_DATE)

  import scala.sys.process._
  val systemDescription = "uname -o -p".!!
  
  val environmentInfo = 
    s"""Tested locally on ${systemDescription} with""" + "\n\n" +
    s"""  * `scalaVersion = ${scalVers}`""" + "\n" +
    s"""  * `sbtVersion = ${sbtVers}`""" + "\n" +
    s"""  * `cargo version: ${cargoVers}`""" + "\n" +
    s"""  * `rustc version: ${rustcVers}`""" + "\n" +
    "\n" +
    s"""Readme generated on ${now}."""

  import scala.xml.XML
  val f = file("target/scala-2.12/scoverage-report/scoverage.xml")
  val coverageBadges =
    (if (f.exists) {
      val report = XML.loadFile(f)
      val branchCov = report.attribute("branch-rate").get.text.toDouble
      val stmtCov = report.attribute("statement-rate").get.text.toDouble

      shieldMdThresh("statement-coverage", stmtCov, 50, 90) + " " +
      shieldMdThresh("branch-coverage", branchCov, 50, 90)
    } else {
      shieldMd("coverage", "unavailable", "red")
    })

  val scalaBadges =
    shieldMd("version", version.value, "lightgrey") +
    buildBadge +
    testBadge +
    coverageBadges

  val rustBadges =
    cargoBuildBadge +
    cargoTestBadge

  val readmeWithBadges = readmeSrc
    .replaceAll("<SCALA-BADGES>", scalaBadges)
    .replaceAll("<RUST-BADGES>", rustBadges)
    .replaceAll("<ENVIRONMENT-INFO>", environmentInfo)

  val FileSnippetRegex = "( *)<FILE:(.*)>".r

  val readmeWithSnippets = FileSnippetRegex.replaceAllIn(
    readmeWithBadges,
    m => {
      val indentation = m.group(1)
      val lines = io.Source.fromFile("../" + m.group(2)).getLines.toList
      val codeLines = if (lines.exists(_.contains("CROP-HEADER"))) {
        lines.dropWhile(l => !l.contains("CROP-HEADER")).tail
      } else lines
      codeLines.map(indentation.+).mkString("\n")
    }
  )

  IO.write(file("../README.md"), readmeWithSnippets)
}

