sbtVersion := "1.2.6"
scalaVersion := "2.12.7"
scalacOptions ++= Seq("-deprecation", "-feature")

organization := "io.github.tyukiand"
name := "frostyc"
version := "0.1.0"
libraryDependencies += "org.typelevel" %% "cats-core" % "1.5.0"
libraryDependencies += "org.typelevel" %% "cats-effect" % "1.1.0"
libraryDependencies += "com.github.scopt" %% "scopt" % "3.7.0"
libraryDependencies += "org.scalactic" %% "scalactic" % "3.0.5"
libraryDependencies += "org.scalatest" %% "scalatest" % "3.0.5" % "test"

antlr4Settings
antlr4Version in Antlr4 := "4.7.1"
antlr4GenListener in Antlr4 := true
antlr4GenVisitor in Antlr4 := true
antlr4Dependency in Antlr4 := "org.antlr" % "antlr4" % "4.7.1"
antlr4PackageName in Antlr4 := Some("frosty.antlr4")

resolvers += Resolver.sonatypeRepo("releases")
addCompilerPlugin("org.spire-math" %% "kind-projector" % "0.9.8")

mainClass in assembly := Some("frosty.Main")
assemblyJarName in assembly := "frostyc.jar"










// Generates scala multiple source code files from `../bytecode_format.rs`.
sourceGenerators in Compile += Def.task{
  val OpcodeTableRustPath = "../bytecode_format.rs"
  val tableFile = file(OpcodeTableRustPath)

  def genFiles(inputs: Set[File]): Set[File] = {
    println(s"Translating Opcode constants from Rust macros to Scala.")

    sealed trait OpcodeEntry {
      def constNameInSource: String
      def opcode: Byte
    }

    case class ChannelName(
      constNameInSource: String,
      opcode: Byte,
      path: List[String],
      typeStr: String
    ) extends OpcodeEntry

    case class TermConstructor(
      constNameInSource: String,
      opcode: Byte
    ) extends OpcodeEntry

    def addGeneratedCodeWarning(
      originalSource: String,
      code: String
    ): String = {
      code
        .split("\n")
        .map("/*!!!*/".+)
        .mkString(
          "/* !!! GENERATED CODE, DO NOT EDIT MANUALLY !!!*/\n" +
          "/* original source: " + originalSource + " */\n" +
          "/* generated by:    build.sbt */\n",
          "\n",
          "\n/* !!! /generated code !!! */"
        )
    }


    // load opcodes from the `../bytecode_format.rs` table
    val opcodeEntries: List[OpcodeEntry] = {

      // all lines from the file containing the opcodes
      val opcodeFileLines = IO.read(inputs.head).split("\n")
    
      // ------------ Run some basic sanity checks on the table. ---------------
      // find start of the table
      val tableStartLineIndex = opcodeFileLines
        .zipWithIndex
        .find(_._1.matches("^.*<TABLE-START>.*$"))
        .get
        ._2
    
      // only the lines of the table, without header comment section
      val opcodeTableLines = opcodeFileLines
        .drop(tableStartLineIndex)
        .filterNot(_.isEmpty)
    
      if (opcodeTableLines.size != 256) {
        printf(
          "Warning: %d != 256 lines after table start\n",
          opcodeTableLines.size
        )
      }
    
      // regex for special comments that look like `// <number>`
      val offsetRegex = "^// *([\\d]+)[^\\d]*$".r
    
      // check that all the positions of the explicit `// <number>` comments are
      // in the right places.
      for {
        (line, idx) <- opcodeFileLines.zipWithIndex
        m <- offsetRegex.findAllMatchIn(line) 
      } {
        val expectedOffset = m.group(1).toInt
        val actualOffset = idx - tableStartLineIndex
        if (expectedOffset != actualOffset) {
          println(
            "Warning: bytecode format table entry " + 
            s"${m.group(1)} at bad line offset ${expectedOffset}, " +
            s"actual offset is ${actualOffset}"
          )
        }
      }
    
      // -------------------------- Parse the table ----------------------------
      // regexes of the interesting strings
      val TermConstructorRegex = (
        "^term_constructor!\\(" +
        "([A-Z_]+),\\s*" +
        "(\\d+)\\s*" +
        "\\);.*"
      ).r
    
      val ChannelNameRegex = (
        "^channel_name!\\(" +
        "([A-Z0-9_]+),\\s*" + // name
        "([\\d]+),\\s*" +   // byte
        "(\"[a-z0-9_/]+\"),\\s*" + // path in quotes
        "\\{([A-Za-z0-9_\\[\\](), ]+)\\}" + // type enclosed in curly braces
        "\\);.*$"
      ).r
    
      val EmptyOrCommented = "^(\\s*|//.*)$".r
    
      // helper method for translating SCREAMING_SNAKE to CamelCase
      def toCamelCase(s: String): String = {
        s.split("_").map(_.toLowerCase.capitalize).mkString
      }

      // extract constructors and channels from the file
      val opcodeEntries: List[OpcodeEntry] = opcodeTableLines.collect {
        case TermConstructorRegex(n, b) => 
          TermConstructor(toCamelCase(n), b.toByte)
        case ChannelNameRegex(n, b, p, t) =>
          ChannelName(
            toCamelCase(n), 
            b.toByte,
            p.replaceAll("\"", "").split("/").toList.tail,
            t
          )
      }(collection.breakOut)

      opcodeEntries
    }

    
    // Generate `frosty.bytecode.format`
    val bytecodeFormatSourceFile: File = {
      val constantDefinitions = opcodeEntries
        .map(e => s"  val ${e.constNameInSource}: Byte = ${e.opcode}")
        .mkString("\n")
    
      // Save the table with opcodes
      val bytecodeFormatSourceFile = (sourceManaged in Compile).value /
        "scala" / "frosty" / "bytecode" / "format" / "package.scala"
    
      IO.write(
        bytecodeFormatSourceFile,
        addGeneratedCodeWarning(
          OpcodeTableRustPath,
          "package frosty.bytecode\n\npackage object format {\n" + 
          constantDefinitions +
          "\n}\n"
        )
      )

      bytecodeFormatSourceFile
    }

    // Generate `frosty/bytecode/builtin/BuiltInChannel.scala`
    val bytecodeBuiltInChannelSourceFile: File = {
      val bytecodeBuiltInChannelSourceFile = (sourceManaged in Compile).value /
        "scala" / "frosty" / "bytecode" / "builtin" / "BuiltInChannel.scala"

      val builtInChannelSourceCode = addGeneratedCodeWarning(
        OpcodeTableRustPath,
        """|package frosty.bytecode.builtin
           |import frosty.bytecode.format
           |import frosty.types.Type
           |import frosty.antlr4.Antlr4FrostyParser
           |import frosty.InMemorySnippet
           |
           |sealed trait BuiltInChannel {
           |  def opcode: Byte
           |  def path: List[String]
           |  def typ: Type
           |}
           |
           |""".stripMargin + 
        (
          for (ChannelName(name, byt, path, typ) <- opcodeEntries) yield {
            s"""|case object ${name} extends BuiltInChannel {
                |  val opcode = format.${name}
                |  val path = List(${path.map("\"" + _ + "\"").mkString(",")})
                |  lazy val typ = {
                |    Antlr4FrostyParser.parseType(
                |      InMemorySnippet(s"<none>", "${typ}")
                |    ).right.get
                |  }
                |}
                |""".stripMargin
          }
        ).mkString("\n") +
        """|
           |object BuiltInChannel {
           |
           |  private val pathToBuiltInChannel
           |  : Map[List[String], BuiltInChannel] = Map(
           |""".stripMargin +
        (
          for (ChannelName(name, byt, path, typ) <- opcodeEntries) yield {
            val pathWithQuotes = path.map(x => '"' + x + '"').mkString(",")
            s"      List(${pathWithQuotes}) -> ${name},"
          }
        ).mkString("\n") +
        """|
           |    )
           |
           |  /** Set of all built-in channels */
           |  val all: Set[BuiltInChannel] = pathToBuiltInChannel.values.toSet
           |
           |  def tryFrom(p: List[String]): Option[BuiltInChannel] =
           |    pathToBuiltInChannel.get(p)
           | 
           |  val typeOf: Map[BuiltInChannel, Type] = List(
           |""".stripMargin +
        (
          for (ChannelName(name, _, _, typ) <- opcodeEntries) yield {
            "    %s -> \"%s\"".format(name.toString, typ)
          }
        ).mkString(",\n") +
        """|
           |  ).map{ 
           |    case (k, v) => (
           |      k,
           |      Antlr4FrostyParser.parseType(
           |        InMemorySnippet(s"<snippet:${v}>", v)
           |      ).right.get
           |    )
           |  }.toMap
           |}""".stripMargin
      )
          
    
      IO.write(
        bytecodeBuiltInChannelSourceFile,
        builtInChannelSourceCode
      )

      bytecodeBuiltInChannelSourceFile
    }

    // List all generated files
    Set(
      bytecodeFormatSourceFile,
      bytecodeBuiltInChannelSourceFile
    )
  }

  val cachedFun = FileFunction.cached(
    cacheBaseDirectory = streams.value.cacheDirectory / "opcodes",
    inStyle = FilesInfo.lastModified,
    outStyle = FilesInfo.exists
  )(genFiles)

  cachedFun(Set(tableFile)).toSeq
}.taskValue
